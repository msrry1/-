//问题 G 套马的汉子
//描述：
//一天 ysj 写出来了一个题目，在实验室里欢呼，wtj 看到他这么高兴，就过去看了看他写了个什么题目。
//题目如下
//如果矩阵 A 中存在这样的一个元素 A[i,j]满足条件:A[i,j]是第 i 行中值最小的元素,且又是第 j 列中值最小
//的元素，则称之为该矩阵的一个马鞍点。请编程计算出 m*n 的矩阵 A 的所有马鞍点。
//如果某一行的最小值为 2，而这一行有 3 个 2，我们认为这三个 2 都是最小的元素。
//wtj 觉得这个题目太简单了，于是给这个题目加了一个难度。
//即现在给你 n 个相同大小的矩阵，每个矩阵的大小是 x*y。如果某个位置，在每个矩阵都是马鞍点，我
//们称为套马点。
//请你找出套马点的个数
//输入：
//第一行输入一个数 n，表示有 n 个矩阵 1<n<10
//第二行输入两个数 x，y 表示矩阵有 x 行，每行 y 个数。 （1<x,y<10）
//然后输入 n*x 行，每行 y 个数。 表示 n 个矩阵。
//每个数的大小为 [0,100]
//输出：
//输出套马点的个数
//样例输入：
//3 2 4
//1 2 3 4
//5 6 7 8
//1 2 3 4
//5 1 7 8
//1 3 2 4
//4 6 7 3
//样例输出：
//1
//提示
//样例中
//在第一个矩阵中 马鞍点的位置为 （1,1）
//在第二个矩阵中 马鞍点的位置为（1,1）（2,2）
//在第三个矩阵中 马鞍点的位置为 （1,1）（2,4）
//只有（1,1）这个位置在三个矩阵中都是马鞍点，所以套马点的个数为 1
//


#include<stdio.h>
int main()
{
	int x,y,n;								
	int r,c,r1,c1;
	scanf("%d",&n);
	scanf("%d%d",&x,&y);
	int s[x+1][y+1];
	int p[x+1][y+1];
	int min;
	int i,j;
	int count = 0;
	for(r = 1;r <= x;r++)
	{
		for(c = 1;c <= y;c++)
		{
			p[r][c] = 0;
		}
	}
	for(i = 1;i <= n;i++)
	{
		for(r = 1;r <= x;r++)
		{
			for(c = 1;c <= y;c++)
			{
				scanf("%d",&s[r][c]);
			}
		}
		for(r = 1;r <= x;r++)
		{
			for(c = 1;c <= y;c++)
			{
				min = s[r][c];
				for(r1 = 1;r1 <= x;r1++)
				{
					min = min < s[r1][c]? min:s[r1][c];
				}
				for(c1 = 1;c1 <= y;c1++)
				{
					min = min < s[r][c1]? min:s[r][c1];
				}
				if(s[r][c] <= min)
				{
					p[r][c]++;
				}
			}	
		}
	}
	for(i = 1;i <= x;i++)
	{
		for(j = 1;j <= y;j++)
		{
			if(p[i][j] == n)
			{
				count++;
			}
		}
	}
	printf("%d",count);
}
